#include<iostream>
#include<vector>
#include<set>
using namespace std;

class Point{

	friend bool operator==(const Point &p1, const Point &p2);
	friend bool operator!=(const Point &p1, const Point &p2);
	public:
	   	Point(int p_x, int p_y):x(p_x),y(p_y){}
	private:
		int x;
		int y;
};
bool operator==(const Point &p1, const Point &p2){
		return p1.x == p2.x && p1.y == p2.y;
}
bool operator!=(const Point &p1, const Point &p2){
		return !(p1 == p2);
}
class Matrix{
	friend ostream &operator<<(ostream &os, const Matrix &matrix);
	friend istream& operator>>(istream &is,   Matrix &m);
	friend Matrix operator^(const Matrix &m1, const Matrix &m2);
	friend bool candidatePoint(const Matrix &m1, const Matrix &m2, Matrix mmxor,std::vector<Point> &points);
	public:
		Matrix(int r, int c):N(r),M(c){
			matrix = new int*[N];
			for(int i = 0; i < N; i++){
				matrix[i] = new int[M];
			}
		}


	private:
		int N;
		int M;
		int **matrix;
	
};
ostream& operator<<(ostream &os,  const Matrix &m){
	for(int i = 0; i < m.N; i++){
		for(int j = 0; j < m.M; j++){
			os << m.matrix[i][j] << " " ;
		}
		os  << std::endl;
	}
	return os;
}

istream& operator>>(istream &is,   Matrix &m){
	for(int i = 0; i < m.N; i++){
		for(int j = 0; j < m.M; j++){
			is >> m.matrix[i][j] ;
		}
	}
	return is;
}

Matrix operator^(const Matrix &m1, const Matrix &m2){
	Matrix tmp = Matrix(m1.N,m2.M);
	for(int i =0; i < tmp.N; i++){
		for(int j = 0; j < tmp.M; j++){
			tmp.matrix[i][j] = m1.matrix[i][j] ^ m2.matrix[i][j];
		}
	}
	return tmp;
}

bool candidatePoint(const Matrix &m1, const Matrix &m2, const Matrix mxor, std::vector<Point> &points){
	bool iszero = true;
	for(int i =0; i < m1.N; i++){
		for(int j = 0; j < m1.M; j++){
			if(m1.matrix[i][j] &  mxor.matrix[i][j]){
				iszero = false;
				points.push_back(Point(i,j));
			}
		}
	}
	if(iszero){
		for(int i =0; i < m2.N; i++){
			for(int j = 0; j < m2.M; j++){
				if(m2.matrix[i][j] &  mxor.matrix[i][j]){
					points.push_back(Point(i,j));
				}
			}
		}
	}
	return iszero;
}
class Comp{
	public:
		bool operator()(const std::vector<Point> &points1, const std::vector<Point> &points2)const{
		    std::vector<Point>::const_iterator v1 = points1.begin();
			std::vector<Point>::const_iterator v2 = points2.begin();
			while(v1 != points1.end() && v2 != points2.end()){
				if(*v1++ != *v2++){
					return false;
				}
			}
			if(v1 != points1.end() || v2 != points2.end()){
				return false;
			}
			return true;
		}
};
			
int main(){
	int N, M , P;
	int i,j;
	std::cin >> N >> M >> P;
	std::vector<Matrix> matrixs;
	for(i = 0; i < P; i++){
		Matrix m = Matrix(N,M);
		std::cin >> m;
		matrixs.push_back(m);
	}
	std::cout << std::endl;
	//for(i = 0; i < P; i++){
	//	std::cout <<matrixs[i];
	//}
	std::set<std::vector<Point>,Comp> s;
	for(i = 0; i < P-1; i++){
		for(j = i+1; j < P; j++){
			Matrix mxor = matrixs[i]^matrixs[j];
			//candidatePoint(matrixs[i],matrixs[j],mxor,points);
		}
	}



}
